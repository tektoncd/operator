package commands

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/openshift-pipelines/pipelines-as-code/pkg/cli"
	"github.com/spf13/cobra"
)

var (
	bugfix                         bool
	clusterserviceversionTemplates = []string{
		"operatorhub/kubernetes/manifests/bases/tektoncd-operator.clusterserviceversion.template.yaml.tmpl",
		"operatorhub/openshift/manifests/bases/openshift-pipelines-operator-rh.clusterserviceversion.template.yaml.tmpl",
	}
)

func BumpCommand(ioStreams *cli.IOStreams) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "bump",
		Short: "Bump components version",
		RunE: func(cmd *cobra.Command, args []string) error {
			if len(args) != 1 {
				return fmt.Errorf("Requires 1 argument")
			}
			filename := args[0]
			return bump(filename, bugfix)
		},
		Annotations: map[string]string{
			"commandType": "main",
		},
	}
	cmd.Flags().BoolVar(&bugfix, "bugfix", false, "Only update bugfix versions of components")
	return cmd
}

type componentUpdate struct {
	Name       string
	OldVersion string
	NewVersion string
	Github     string
}

func bump(filename string, bugfix bool) error {
	newComponents := map[string]component{}
	components, err := ReadComponents(filename)
	if err != nil {
		return err
	}
	var updates []componentUpdate
	for name, component := range components {
		newComponent, err := bumpComponent(name, component, bugfix)
		if err != nil {
			return err
		}
		if newComponent.Version != component.Version {
			updates = append(updates, componentUpdate{
				Name:       name,
				OldVersion: component.Version,
				NewVersion: newComponent.Version,
				Github:     component.Github,
			})
		}
		newComponents[name] = newComponent
	}
	if err := writeComponents(filename, newComponents); err != nil {
		return err
	}
	if err := updateClusterserviceversionTemplates(newComponents, clusterserviceversionTemplates); err != nil {
		return err
	}
	// Output updates in a machine-readable format for the workflow to consume
	if len(updates) > 0 {
		fmt.Fprintf(os.Stderr, "BUMP_UPDATES_START\n")
		for _, u := range updates {
			fmt.Fprintf(os.Stderr, "%s|%s|%s|%s\n", u.Name, u.OldVersion, u.NewVersion, u.Github)
		}
		fmt.Fprintf(os.Stderr, "BUMP_UPDATES_END\n")
	}
	return nil
}

func bumpComponent(name string, c component, bugfix bool) (component, error) {
	newVersion := c.Version
	newerVersions, err := checkComponentNewerVersions(c, bugfix)
	if err != nil {
		return component{}, err
	}
	if len(newerVersions) > 0 {
		// Get the latest one
		sort.Sort(newerVersions) // sort just in case
		newVersion = "v" + newerVersions[len(newerVersions)-1].String()
	}
	return component{
		Github:  c.Github,
		Version: newVersion,
	}, nil
}

func updateClusterserviceversionTemplates(newComponents map[string]component, csvts []string) error {
	for _, csvt := range csvts {
		tmpl, err := template.ParseFiles(csvt)
		if err != nil {
			return err
		}
		template := strings.TrimSuffix(csvt, filepath.Ext(csvt))
		f, err := os.Create(template)
		if err != nil {
			return err
		}
		defer f.Close()
		header := fmt.Sprintf("# THIS FILE IS AUTOGENERATED ! Please update %s instead.\n", filepath.Base(csvt))
		if _, err := f.WriteString(header); err != nil {
			return err
		}
		if err := tmpl.Execute(f, mytemplate{Versions: newComponents}); err != nil {
			return err
		}
	}
	return nil
}

type mytemplate struct {
	Versions map[string]component
}
